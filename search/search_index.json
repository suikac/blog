{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"My blog I mainly write about CS, and other fun things","title":"Home"},{"location":"#my-blog","text":"I mainly write about CS, and other fun things","title":"My blog"},{"location":"distributed/","text":"MIT CS 6.824 Classic Course on distributed system concurrent primitive of golang introduced here lab the labs explore MapReduce (distributed computing), Rafe (consensus algorithm), Raft/Sharded KV (distributed DataBase) lab1 implement mapreduce framework, with one coordinator, and several workers to perform distributed computation remember to use mu.Lock() , mu.UnLock() for every handler of RPC to prevent race condition use go routine and function closure to set up timer, sending requests in parallel, etc to increase performance go func(){ // wait for event }() Lab 2 Raft implementation consist of leader election, Log replication, Log Compaction, and persistance lab 2A use timer to record election timeout, and heartbeat timeout parallelism on sending to all peers since they are independent lab 2B thoroughtly understand what each field stands for make your life much easier several replicators goroutines that dedicate on retrying replication on each peer heartbeat also acts as a one time replicator.","title":"CS6.824"},{"location":"distributed/#mit-cs-6824","text":"Classic Course on distributed system","title":"MIT CS 6.824"},{"location":"distributed/#concurrent-primitive-of-golang","text":"introduced here","title":"concurrent primitive of golang"},{"location":"distributed/#lab","text":"the labs explore MapReduce (distributed computing), Rafe (consensus algorithm), Raft/Sharded KV (distributed DataBase)","title":"lab"},{"location":"distributed/#lab1","text":"implement mapreduce framework, with one coordinator, and several workers to perform distributed computation remember to use mu.Lock() , mu.UnLock() for every handler of RPC to prevent race condition use go routine and function closure to set up timer, sending requests in parallel, etc to increase performance go func(){ // wait for event }()","title":"lab1"},{"location":"distributed/#lab-2","text":"Raft implementation consist of leader election, Log replication, Log Compaction, and persistance","title":"Lab 2"},{"location":"distributed/#lab-2a","text":"use timer to record election timeout, and heartbeat timeout parallelism on sending to all peers since they are independent","title":"lab 2A"},{"location":"distributed/#lab-2b","text":"thoroughtly understand what each field stands for make your life much easier several replicators goroutines that dedicate on retrying replication on each peer heartbeat also acts as a one time replicator.","title":"lab 2B"}]}